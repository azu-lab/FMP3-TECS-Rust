/*
 * This file was automatically generated by tecsgen.
 * This file is not intended to be edited.
 */
/* #[<PREAMBLE>]#
 * Don't edit the comments between #[<...>]# and #[</...>]#
 * These comment are used by tecsmerege when merging.
 *
 * call port function #_TCPF_#
 * call port: cTDR signature: sTDR context:task
 *   ER             cTDR_reset( );
 *   ER             cTDR_sendSOP( bool_t b_client );
 *   ER             cTDR_receiveSOP( bool_t b_client );
 *   ER             cTDR_sendEOP( bool_t b_continue );
 *   ER             cTDR_receiveEOP( bool_t b_continue );
 *   ER             cTDR_putInt8( int8_t in );
 *   ER             cTDR_putInt16( int16_t in );
 *   ER             cTDR_putInt32( int32_t in );
 *   ER             cTDR_putInt64( int64_t in );
 *   ER             cTDR_putInt128( int128_t in );
 *   ER             cTDR_getInt8( int8_t* out );
 *   ER             cTDR_getInt16( int16_t* out );
 *   ER             cTDR_getInt32( int32_t* out );
 *   ER             cTDR_getInt64( int64_t* out );
 *   ER             cTDR_getInt128( int128_t* out );
 *   ER             cTDR_putUInt8( uint8_t in );
 *   ER             cTDR_putUInt16( uint16_t in );
 *   ER             cTDR_putUInt32( uint32_t in );
 *   ER             cTDR_putUInt64( uint64_t in );
 *   ER             cTDR_putUInt128( uint128_t in );
 *   ER             cTDR_getUInt8( uint8_t* out );
 *   ER             cTDR_getUInt16( uint16_t* out );
 *   ER             cTDR_getUInt32( uint32_t* out );
 *   ER             cTDR_getUInt64( uint64_t* out );
 *   ER             cTDR_getUInt128( uint128_t* out );
 *   ER             cTDR_putChar( char_t in );
 *   ER             cTDR_getChar( char_t* out );
 *   ER             cTDR_putBool( bool_t in );
 *   ER             cTDR_getBool( bool_t* out );
 *   ER             cTDR_putFloat32( float32_t in );
 *   ER             cTDR_putDouble64( double64_t in );
 *   ER             cTDR_getFloat32( float32_t* out );
 *   ER             cTDR_getDouble64( double64_t* out );
 *   ER             cTDR_putSChar( schar_t in );
 *   ER             cTDR_putShort( short_t in );
 *   ER             cTDR_putInt( int_t in );
 *   ER             cTDR_putLong( long_t in );
 *   ER             cTDR_getSChar( schar_t* out );
 *   ER             cTDR_getShort( short_t* out );
 *   ER             cTDR_getInt( int_t* out );
 *   ER             cTDR_getLong( long_t* out );
 *   ER             cTDR_putUChar( uchar_t in );
 *   ER             cTDR_putUShort( ushort_t in );
 *   ER             cTDR_putUInt( uint_t in );
 *   ER             cTDR_putULong( ulong_t in );
 *   ER             cTDR_getUChar( unsigned char* out );
 *   ER             cTDR_getUShort( ushort_t* out );
 *   ER             cTDR_getUInt( uint_t* out );
 *   ER             cTDR_getULong( ulong_t* out );
 *   ER             cTDR_putIntptr( const intptr_t ptr );
 *   ER             cTDR_getIntptr( intptr_t* ptr );
 * call port: cEventflag signature: sEventflag context:task
 *   ER             cEventflag_set( FLGPTN setPattern );
 *   ER             cEventflag_clear( FLGPTN clearPattern );
 *   ER             cEventflag_wait( FLGPTN waitPattern, MODE waitMode, FLGPTN* p_flagPattern );
 *   ER             cEventflag_waitPolling( FLGPTN waitPattern, MODE waitMode, FLGPTN* p_flagPattern );
 *   ER             cEventflag_waitTimeout( FLGPTN waitPattern, MODE waitMode, FLGPTN* p_flagPattern, TMO timeout );
 *   ER             cEventflag_initialize( );
 *   ER             cEventflag_refer( T_RFLG* pk_eventflagStatus );
 * call port: cLockChannel signature: sSemaphore context:task optional:true
 *   bool_t     is_cLockChannel_joined()                     check if joined
 *   ER             cLockChannel_signal( );
 *   ER             cLockChannel_wait( );
 *   ER             cLockChannel_waitPolling( );
 *   ER             cLockChannel_waitTimeout( TMO timeout );
 *   ER             cLockChannel_initialize( );
 *   ER             cLockChannel_refer( T_RSEM* pk_semaphoreStatus );
 *
 * #[</PREAMBLE>]# */

/* Put prototype declaration and/or variale definition here #_PAC_# */
#include "tMarshaler_sService_tecsgen.h"

#ifndef E_OK
#define	E_OK	0		/* success */
#define	E_ID	(-18)	/* illegal ID */
#endif

/* entry port function #_TEPF_# */
/* #[<ENTRY_PORT>]# eClientEntry
 * entry port: eClientEntry
 * signature:  sService
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eClientEntry_migrate
 * name:         eClientEntry_migrate
 * global_name:  tMarshaler_sService_eClientEntry_migrate
 * oneway:       true
 * #[</ENTRY_FUNC>]# */
ER
eClientEntry_migrate(CELLIDX idx, int_t no)
{
    /* (GenTransparentMarshler0101) */
    ER  retval_ = E_OK;
    ER      ercd_;
    FLGPTN  flgptn;
    int16_t  func_id_ = 1;    /* id of migrate: 1 */
    tMarshaler_sService_CB *p_cellcb;

    if( VALID_IDX( idx ) ){
        p_cellcb = GET_CELLCB(idx);
    }else{
         return ERCD( E_RPC, E_ID );
    }
    /* Channel Lock */
    if( is_cLockChannel_joined() )
      cLockChannel_wait();

    /* SOPの送出 (GenTransparentMarshler0102) */
    if( ( ercd_ = cTDR_sendSOP( true ) ) != E_OK )
      goto error_reset;
    /* 関数 id の送出 (GenTransparentMarshler0103) */
    if( ( ercd_ = cTDR_putInt16( func_id_ ) ) != E_OK )
        goto error_reset;
    /* 入力引数送出 (GenTransparentMarshler0104) */
    if( ( ercd_ = cTDR_putInt( (int_t)no ) ) != E_OK )
        goto error_reset;
    /* EOPの送出（パケットの掃きだし）(GenTransparentMarshler0105) */
    if( (ercd_=cTDR_sendEOP(false)) != E_OK )
        goto error_reset;

    /* Channel Lock */
    if( is_cLockChannel_joined() )
      cLockChannel_signal();
    return retval_;

error_reset:
    if( ercd_ != ERCD( E_RPC, E_RESET ) )
        (void)cTDR_reset();
    /* Channel Lock */
    if( is_cLockChannel_joined() )
      cLockChannel_signal();

    return ercd_;
}

/* #[<ENTRY_FUNC>]# eClientEntry_terminate
 * name:         eClientEntry_terminate
 * global_name:  tMarshaler_sService_eClientEntry_terminate
 * oneway:       true
 * #[</ENTRY_FUNC>]# */
ER
eClientEntry_terminate(CELLIDX idx, int_t no)
{
    /* (GenTransparentMarshler0101) */
    ER  retval_ = E_OK;
    ER      ercd_;
    FLGPTN  flgptn;
    int16_t  func_id_ = 2;    /* id of terminate: 2 */
    tMarshaler_sService_CB *p_cellcb;

    if( VALID_IDX( idx ) ){
        p_cellcb = GET_CELLCB(idx);
    }else{
         return ERCD( E_RPC, E_ID );
    }
    /* Channel Lock */
    if( is_cLockChannel_joined() )
      cLockChannel_wait();

    /* SOPの送出 (GenTransparentMarshler0102) */
    if( ( ercd_ = cTDR_sendSOP( true ) ) != E_OK )
      goto error_reset;
    /* 関数 id の送出 (GenTransparentMarshler0103) */
    if( ( ercd_ = cTDR_putInt16( func_id_ ) ) != E_OK )
        goto error_reset;
    /* 入力引数送出 (GenTransparentMarshler0104) */
    if( ( ercd_ = cTDR_putInt( (int_t)no ) ) != E_OK )
        goto error_reset;
    /* EOPの送出（パケットの掃きだし）(GenTransparentMarshler0105) */
    if( (ercd_=cTDR_sendEOP(false)) != E_OK )
        goto error_reset;

    /* Channel Lock */
    if( is_cLockChannel_joined() )
      cLockChannel_signal();
    return retval_;

error_reset:
    if( ercd_ != ERCD( E_RPC, E_RESET ) )
        (void)cTDR_reset();
    /* Channel Lock */
    if( is_cLockChannel_joined() )
      cLockChannel_signal();

    return ercd_;
}

/* #[<POSTAMBLE>]#
 *   Put non-entry functions below.
 * #[</POSTAMBLE>]#*/
